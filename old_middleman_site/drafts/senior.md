
A few years back I was working in a small team of senior programmers when the
first junior joined the team. There was a noticeable difference in experience and
maturity, so all parties agreed that he would start at a lower day rate. It was
also clear that that gap could be closed rapidly if it turned out he was indeed
pulling his own weight.

To make that a bit more concrete, the CTO asked me to give him some specific
advice: here are some areas you can improve in, some actionable objectives so
that when they are met, you too are considered "senior".

Since then I've been mulling this over, what does it mean to be a "senior
engineer"? The obvious answer is saying that you're experienced, that you have
the years to show for it, but that seems too easy. What do people learn as they
age and accumulate work experience? How do they change? What aspects of
more experienced colleagues do we value?

I've been keeping notes, collecting resources, and have gradually distilled my
own answer. It comes in the form of a number rules. I'm not saying I abide by
these all the time. Some days it works better than others. Being a senior
engineer is not something you graduate into, it's something you make a reality
through your actions, every day anew.

# People Come first

<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">Some people probably call me soft but I think helping people &amp; communicating is increasingly my job as a senior engineer -- not writing code</p>&mdash; Eric Turcotte (@ericturcotte) <a href="https://twitter.com/ericturcotte/status/667618370573864960">November 20, 2015</a></blockquote>

You can't be effective at your job without being good with people. It's a simple
as that. You want to be that mythical 10x developer? Then hone your
communication skills! Good communication is the most effective multiplier
available for the productivity, and the quality of work, of you and your team.

Some say "you can't be good at everything", to defend coders with bad people
skills. But guess what, you can learn almost everything, and living with other
human beings for a few decades should have given you enough time to develop
basic empathy and psychological insight. If you're willing to learn, that is.

Be impeccable in your writing. Never attack or rant. Use correct spelling and
grammar. Be respectful. Don't respond while agitated, but cool down first.
Violating any of these rules means stealing cognitive resources, energy, and joy
from your coworkers.

# Understand Efficiency vs Thoroughness

There is a constant tension while coding between efficiently cranking out
features at a steady pace, and being thorough, making sure all cases are
covered, and the end result is robust and maintainable. This is known as the
[ETTO Principle](https://en.wikipedia.org/wiki/Efficiency%E2%80%93thoroughness_trade-off_principle).
Which point on that spectrum you should aim for changes every day, depending on
many contextual factors.

On the one hand there are business needs. There is a good chance the software
you work on is part of some product or service, something that creates value for
people, and people are in turn willing to pay for. This value, and hence,
revenue, needs to be more than what it costs to build and run the thing, or it
disappears. From that point of view all that matters is efficiently turning out
new features.

But software has this annoying tendency to become a mess, this is due to
[Software Entropy](https://en.wikipedia.org/wiki/Software_entropy), which leads
to [Technical Debt](https://en.wikipedia.org/wiki/Technical_debt). This makes it
harder to alter or extend the system, and makes it easy to inadvertently
introduce bugs. End result: you grind to a halt. You can spot this by noticing
you are "running to a standstil", more and more busywork, less and less real
output.

As a senior developer you need to be a good code shepherd, you need to guide
your code base through stormy weather, ensuring its longevity, making it thrive.
Prevention is better than cure, try to get the architectural design right early
on, make sure the whole team buys into it. Establish a strong culture of code
reviews.

Still, your code will become a little messier every day, that's what entropy
does. It's your job to gracefully push back against it. Most of this is done in
tiny increments, little daily refactorings. Occasionally you might have to rip a
part out and replace it, or change things in one big move across the code base.
These things might take days, even weeks, but because you understand the ETTO
principle you know that at this point in time it's justified, and you can
explain that confidently to fellow colleagues and stakeholders.

These big changes might require coordination and buy-in from many people. But by
now you know that communication is key, so you talk about it early and often,
ensuring a smooth transition and causing minimal frustration.

# Build the Right Thing

<blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">Ultimately building the right thing is of better use to the world than knowing every optimization, or understanding every algorithm.</p>&mdash; Sarah Mei (@sarahmei) <a href="https://twitter.com/sarahmei/status/597276656424734720">May 10, 2015</a></blockquote>

# Challenge Your Assumptions

# Be in Charge of Your Own Growth

# Context is King - The Holistic Programmer

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
